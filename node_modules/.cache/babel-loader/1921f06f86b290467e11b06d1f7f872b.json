{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Connection_instances, _Connection_url, _Connection_transport, _Connection_delay, _Connection_lastId, _Connection_sessions, _Connection_closed, _Connection_callbacks, _Connection_manuallyAttached, _Connection_onClose, _CDPSessionImpl_sessionId, _CDPSessionImpl_targetType, _CDPSessionImpl_callbacks, _CDPSessionImpl_connection;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { debug } from './Debug.js';\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\nimport { EventEmitter } from './EventEmitter.js';\nimport { ProtocolError } from './Errors.js';\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexport const ConnectionEmittedEvents = {\n  Disconnected: Symbol('Connection.Disconnected')\n};\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n  constructor(url, transport) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    super();\n    _Connection_instances.add(this);\n    _Connection_url.set(this, void 0);\n    _Connection_transport.set(this, void 0);\n    _Connection_delay.set(this, void 0);\n    _Connection_lastId.set(this, 0);\n    _Connection_sessions.set(this, new Map());\n    _Connection_closed.set(this, false);\n    _Connection_callbacks.set(this, new Map());\n    _Connection_manuallyAttached.set(this, new Set());\n    __classPrivateFieldSet(this, _Connection_url, url, \"f\");\n    __classPrivateFieldSet(this, _Connection_delay, delay, \"f\");\n    __classPrivateFieldSet(this, _Connection_transport, transport, \"f\");\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = this.onMessage.bind(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).bind(this);\n  }\n  static fromSession(session) {\n    return session.connection();\n  }\n  /**\n   * @internal\n   */\n  get _closed() {\n    return __classPrivateFieldGet(this, _Connection_closed, \"f\");\n  }\n  /**\n   * @internal\n   */\n  get _sessions() {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\");\n  }\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId) {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId) || null;\n  }\n  url() {\n    return __classPrivateFieldGet(this, _Connection_url, \"f\");\n  }\n  send(method) {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    const params = (arguments.length <= 1 ? 0 : arguments.length - 1) ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n    const id = this._rawSend({\n      method,\n      params\n    });\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _Connection_callbacks, \"f\").set(id, {\n        resolve,\n        reject,\n        error: new ProtocolError(),\n        method\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  _rawSend(message) {\n    var _a;\n    const id = __classPrivateFieldSet(this, _Connection_lastId, (_a = __classPrivateFieldGet(this, _Connection_lastId, \"f\"), ++_a), \"f\");\n    const stringifiedMessage = JSON.stringify(Object.assign({}, message, {\n      id\n    }));\n    debugProtocolSend(stringifiedMessage);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").send(stringifiedMessage);\n    return id;\n  }\n  /**\n   * @internal\n   */\n  async onMessage(message) {\n    if (__classPrivateFieldGet(this, _Connection_delay, \"f\")) {\n      await new Promise(f => {\n        return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, \"f\"));\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);\n      __classPrivateFieldGet(this, _Connection_sessions, \"f\").set(sessionId, session);\n      this.emit('sessionattached', session);\n      const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit('sessionattached', session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.params.sessionId);\n      if (session) {\n        session._onClosed();\n        __classPrivateFieldGet(this, _Connection_sessions, \"f\").delete(object.params.sessionId);\n        this.emit('sessiondetached', session);\n        const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit('sessiondetached', session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n      if (session) {\n        session._onMessage(object);\n      }\n    } else if (object.id) {\n      const callback = __classPrivateFieldGet(this, _Connection_callbacks, \"f\").get(object.id);\n      // Callbacks could be all rejected if someone has called `.dispose()`.\n      if (callback) {\n        __classPrivateFieldGet(this, _Connection_callbacks, \"f\").delete(object.id);\n        if (object.error) {\n          callback.reject(createProtocolError(callback.error, callback.method, object));\n        } else {\n          callback.resolve(object.result);\n        }\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n  dispose() {\n    __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).call(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").close();\n  }\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId) {\n    return !__classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").has(targetId);\n  }\n  /**\n   * @internal\n   */\n  async _createSession(targetInfo) {\n    let isAutoAttachEmulated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!isAutoAttachEmulated) {\n      __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").add(targetInfo.targetId);\n    }\n    const {\n      sessionId\n    } = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").delete(targetInfo.targetId);\n    const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(targetInfo) {\n    return await this._createSession(targetInfo, false);\n  }\n}\n_Connection_url = new WeakMap(), _Connection_transport = new WeakMap(), _Connection_delay = new WeakMap(), _Connection_lastId = new WeakMap(), _Connection_sessions = new WeakMap(), _Connection_closed = new WeakMap(), _Connection_callbacks = new WeakMap(), _Connection_manuallyAttached = new WeakMap(), _Connection_instances = new WeakSet(), _Connection_onClose = function _Connection_onClose() {\n  if (__classPrivateFieldGet(this, _Connection_closed, \"f\")) {\n    return;\n  }\n  __classPrivateFieldSet(this, _Connection_closed, true, \"f\");\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = undefined;\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = undefined;\n  for (const callback of __classPrivateFieldGet(this, _Connection_callbacks, \"f\").values()) {\n    callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n  }\n  __classPrivateFieldGet(this, _Connection_callbacks, \"f\").clear();\n  for (const session of __classPrivateFieldGet(this, _Connection_sessions, \"f\").values()) {\n    session._onClosed();\n  }\n  __classPrivateFieldGet(this, _Connection_sessions, \"f\").clear();\n  this.emit(ConnectionEmittedEvents.Disconnected);\n};\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexport const CDPSessionEmittedEvents = {\n  Disconnected: Symbol('CDPSession.Disconnected')\n};\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nexport class CDPSession extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  connection() {\n    throw new Error('Not implemented');\n  }\n  send() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    throw new Error('Not implemented');\n  }\n}\n/**\n * @internal\n */\nexport class CDPSessionImpl extends CDPSession {\n  /**\n   * @internal\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    _CDPSessionImpl_sessionId.set(this, void 0);\n    _CDPSessionImpl_targetType.set(this, void 0);\n    _CDPSessionImpl_callbacks.set(this, new Map());\n    _CDPSessionImpl_connection.set(this, void 0);\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, \"f\");\n  }\n  connection() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\");\n  }\n  send(method) {\n    if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`));\n    }\n    // See the comment in Connection#send explaining why we do this.\n    const params = (arguments.length <= 1 ? 0 : arguments.length - 1) ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n    const id = __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")._rawSend({\n      sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\"),\n      method,\n      params\n    });\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").set(id, {\n        resolve,\n        reject,\n        error: new ProtocolError(),\n        method\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  _onMessage(object) {\n    const callback = object.id ? __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").get(object.id) : undefined;\n    if (object.id && callback) {\n      __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").delete(object.id);\n      if (object.error) {\n        callback.reject(createProtocolError(callback.error, callback.method, object));\n      } else {\n        callback.resolve(object.result);\n      }\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n      throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`);\n    }\n    await __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\").send('Target.detachFromTarget', {\n      sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\")\n    });\n  }\n  /**\n   * @internal\n   */\n  _onClosed() {\n    for (const callback of __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").values()) {\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    }\n    __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").clear();\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, undefined, \"f\");\n    this.emit(CDPSessionEmittedEvents.Disconnected);\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\");\n  }\n}\n_CDPSessionImpl_sessionId = new WeakMap(), _CDPSessionImpl_targetType = new WeakMap(), _CDPSessionImpl_callbacks = new WeakMap(), _CDPSessionImpl_connection = new WeakMap();\nfunction createProtocolError(error, method, object) {\n  let message = `Protocol error (${method}): ${object.error.message}`;\n  if ('data' in object.error) {\n    message += ` ${object.error.data}`;\n  }\n  return rewriteError(error, message, object.error.message);\n}\nfunction rewriteError(error, message, originalMessage) {\n  error.message = message;\n  error.originalMessage = originalMessage !== null && originalMessage !== void 0 ? originalMessage : error.originalMessage;\n  return error;\n}\n/**\n * @internal\n */\nexport function isTargetClosedError(err) {\n  return err.message.includes('Target closed') || err.message.includes('Session closed');\n}","map":{"version":3,"mappings":"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","names":["assert","debug","debugProtocolSend","debugProtocolReceive","EventEmitter","ProtocolError","ConnectionEmittedEvents","Disconnected","Symbol","Connection","constructor","url","transport","delay","_Connection_url","_Connection_transport","_Connection_delay","_Connection_lastId","_Connection_sessions","Map","_Connection_closed","_Connection_callbacks","_Connection_manuallyAttached","Set","__classPrivateFieldSet","__classPrivateFieldGet","onmessage","onMessage","bind","onclose","fromSession","session","connection","_closed","_sessions","sessionId","get","send","method","params","undefined","id","_rawSend","Promise","resolve","reject","set","error","message","_a","stringifiedMessage","JSON","stringify","Object","assign","f","setTimeout","object","parse","CDPSessionImpl","targetInfo","type","emit","parentSession","_onClosed","delete","_onMessage","callback","createProtocolError","result","dispose","close","isAutoAttached","targetId","has","_createSession","isAutoAttachEmulated","add","flatten","Error","createSession","values","rewriteError","clear","CDPSessionEmittedEvents","CDPSession","detach","targetType","_CDPSessionImpl_sessionId","_CDPSessionImpl_targetType","_CDPSessionImpl_callbacks","_CDPSessionImpl_connection","data","originalMessage","isTargetClosedError","err","includes"],"sources":["../../../../src/common/Connection.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}