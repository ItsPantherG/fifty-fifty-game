{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Dialog_client, _Dialog_type, _Dialog_message, _Dialog_defaultValue, _Dialog_handled;\nimport { assert } from '../util/assert.js';\n/**\n * Dialog instances are dispatched by the {@link Page} via the `dialog` event.\n *\n * @remarks\n *\n * @example\n *\n * ```ts\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   page.on('dialog', async dialog => {\n *     console.log(dialog.message());\n *     await dialog.dismiss();\n *     await browser.close();\n *   });\n *   page.evaluate(() => alert('1'));\n * })();\n * ```\n *\n * @public\n */\nexport class Dialog {\n  /**\n   * @internal\n   */\n  constructor(client, type, message) {\n    let defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    _Dialog_client.set(this, void 0);\n    _Dialog_type.set(this, void 0);\n    _Dialog_message.set(this, void 0);\n    _Dialog_defaultValue.set(this, void 0);\n    _Dialog_handled.set(this, false);\n    __classPrivateFieldSet(this, _Dialog_client, client, \"f\");\n    __classPrivateFieldSet(this, _Dialog_type, type, \"f\");\n    __classPrivateFieldSet(this, _Dialog_message, message, \"f\");\n    __classPrivateFieldSet(this, _Dialog_defaultValue, defaultValue, \"f\");\n  }\n  /**\n   * @returns The type of the dialog.\n   */\n  type() {\n    return __classPrivateFieldGet(this, _Dialog_type, \"f\");\n  }\n  /**\n   * @returns The message displayed in the dialog.\n   */\n  message() {\n    return __classPrivateFieldGet(this, _Dialog_message, \"f\");\n  }\n  /**\n   * @returns The default value of the prompt, or an empty string if the dialog\n   * is not a `prompt`.\n   */\n  defaultValue() {\n    return __classPrivateFieldGet(this, _Dialog_defaultValue, \"f\");\n  }\n  /**\n   * @param promptText - optional text that will be entered in the dialog\n   * prompt. Has no effect if the dialog's type is not `prompt`.\n   *\n   * @returns A promise that resolves when the dialog has been accepted.\n   */\n  async accept(promptText) {\n    assert(!__classPrivateFieldGet(this, _Dialog_handled, \"f\"), 'Cannot accept dialog which is already handled!');\n    __classPrivateFieldSet(this, _Dialog_handled, true, \"f\");\n    await __classPrivateFieldGet(this, _Dialog_client, \"f\").send('Page.handleJavaScriptDialog', {\n      accept: true,\n      promptText: promptText\n    });\n  }\n  /**\n   * @returns A promise which will resolve once the dialog has been dismissed\n   */\n  async dismiss() {\n    assert(!__classPrivateFieldGet(this, _Dialog_handled, \"f\"), 'Cannot dismiss dialog which is already handled!');\n    __classPrivateFieldSet(this, _Dialog_handled, true, \"f\");\n    await __classPrivateFieldGet(this, _Dialog_client, \"f\").send('Page.handleJavaScriptDialog', {\n      accept: false\n    });\n  }\n}\n_Dialog_client = new WeakMap(), _Dialog_type = new WeakMap(), _Dialog_message = new WeakMap(), _Dialog_defaultValue = new WeakMap(), _Dialog_handled = new WeakMap();","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAAQA,MAAM,QAAO,mBAAmB;AAIxC;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAM,MAAOC,MAAM;EAOjB;;;EAGAC,YACEC,MAAkB,EAClBC,IAA8B,EAC9BC,OAAe,EACE;IAAA,IAAjBC,YAAY,uEAAG,EAAE;IAbnBC;IACAC;IACAC;IACAC;IACAC,0BAAW,KAAK;IAWdC,2BAAI,kBAAWT,MAAM;IACrBS,2BAAI,gBAASR,IAAI;IACjBQ,2BAAI,mBAAYP,OAAO;IACvBO,2BAAI,wBAAiBN,YAAY;EACnC;EAEA;;;EAGAF,IAAI;IACF,OAAOS,2BAAI,oBAAM;EACnB;EAEA;;;EAGAR,OAAO;IACL,OAAOQ,2BAAI,uBAAS;EACtB;EAEA;;;;EAIAP,YAAY;IACV,OAAOO,2BAAI,4BAAc;EAC3B;EAEA;;;;;;EAMA,MAAMC,MAAM,CAACC,UAAmB;IAC9Bf,MAAM,CAAC,CAACa,2BAAI,uBAAS,EAAE,gDAAgD,CAAC;IACxED,2BAAI,mBAAY,IAAI;IACpB,MAAMC,2BAAI,sBAAQ,CAACG,IAAI,CAAC,6BAA6B,EAAE;MACrDF,MAAM,EAAE,IAAI;MACZC,UAAU,EAAEA;KACb,CAAC;EACJ;EAEA;;;EAGA,MAAME,OAAO;IACXjB,MAAM,CAAC,CAACa,2BAAI,uBAAS,EAAE,iDAAiD,CAAC;IACzED,2BAAI,mBAAY,IAAI;IACpB,MAAMC,2BAAI,sBAAQ,CAACG,IAAI,CAAC,6BAA6B,EAAE;MACrDF,MAAM,EAAE;KACT,CAAC;EACJ","names":["assert","Dialog","constructor","client","type","message","defaultValue","_Dialog_client","_Dialog_type","_Dialog_message","_Dialog_defaultValue","_Dialog_handled","__classPrivateFieldSet","__classPrivateFieldGet","accept","promptText","send","dismiss"],"sources":["../../../../src/common/Dialog.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}