{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HTTPResponse_instances, _HTTPResponse_client, _HTTPResponse_request, _HTTPResponse_contentPromise, _HTTPResponse_bodyLoadedPromise, _HTTPResponse_bodyLoadedPromiseFulfill, _HTTPResponse_remoteAddress, _HTTPResponse_status, _HTTPResponse_statusText, _HTTPResponse_url, _HTTPResponse_fromDiskCache, _HTTPResponse_fromServiceWorker, _HTTPResponse_headers, _HTTPResponse_securityDetails, _HTTPResponse_timing, _HTTPResponse_parseStatusTextFromExtrInfo;\nimport { SecurityDetails } from './SecurityDetails.js';\nimport { ProtocolError } from './Errors.js';\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\nexport class HTTPResponse {\n  /**\n   * @internal\n   */\n  constructor(client, request, responsePayload, extraInfo) {\n    _HTTPResponse_instances.add(this);\n    _HTTPResponse_client.set(this, void 0);\n    _HTTPResponse_request.set(this, void 0);\n    _HTTPResponse_contentPromise.set(this, null);\n    _HTTPResponse_bodyLoadedPromise.set(this, void 0);\n    _HTTPResponse_bodyLoadedPromiseFulfill.set(this, () => {});\n    _HTTPResponse_remoteAddress.set(this, void 0);\n    _HTTPResponse_status.set(this, void 0);\n    _HTTPResponse_statusText.set(this, void 0);\n    _HTTPResponse_url.set(this, void 0);\n    _HTTPResponse_fromDiskCache.set(this, void 0);\n    _HTTPResponse_fromServiceWorker.set(this, void 0);\n    _HTTPResponse_headers.set(this, {});\n    _HTTPResponse_securityDetails.set(this, void 0);\n    _HTTPResponse_timing.set(this, void 0);\n    __classPrivateFieldSet(this, _HTTPResponse_client, client, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_request, request, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_bodyLoadedPromise, new Promise(fulfill => {\n      __classPrivateFieldSet(this, _HTTPResponse_bodyLoadedPromiseFulfill, fulfill, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_remoteAddress, {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    }, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_statusText, __classPrivateFieldGet(this, _HTTPResponse_instances, \"m\", _HTTPResponse_parseStatusTextFromExtrInfo).call(this, extraInfo) || responsePayload.statusText, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_url, request.url(), \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_fromDiskCache, !!responsePayload.fromDiskCache, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_fromServiceWorker, !!responsePayload.fromServiceWorker, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_status, extraInfo ? extraInfo.statusCode : responsePayload.status, \"f\");\n    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;\n    for (const [key, value] of Object.entries(headers)) {\n      __classPrivateFieldGet(this, _HTTPResponse_headers, \"f\")[key.toLowerCase()] = value;\n    }\n    __classPrivateFieldSet(this, _HTTPResponse_securityDetails, responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null, \"f\");\n    __classPrivateFieldSet(this, _HTTPResponse_timing, responsePayload.timing || null, \"f\");\n  }\n  /**\n   * @internal\n   */\n  _resolveBody(err) {\n    if (err) {\n      return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromiseFulfill, \"f\").call(this, err);\n    }\n    return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromiseFulfill, \"f\").call(this);\n  }\n  /**\n   * @returns The IP address and port number used to connect to the remote\n   * server.\n   */\n  remoteAddress() {\n    return __classPrivateFieldGet(this, _HTTPResponse_remoteAddress, \"f\");\n  }\n  /**\n   * @returns The URL of the response.\n   */\n  url() {\n    return __classPrivateFieldGet(this, _HTTPResponse_url, \"f\");\n  }\n  /**\n   * @returns True if the response was successful (status in the range 200-299).\n   */\n  ok() {\n    // TODO: document === 0 case?\n    return __classPrivateFieldGet(this, _HTTPResponse_status, \"f\") === 0 || __classPrivateFieldGet(this, _HTTPResponse_status, \"f\") >= 200 && __classPrivateFieldGet(this, _HTTPResponse_status, \"f\") <= 299;\n  }\n  /**\n   * @returns The status code of the response (e.g., 200 for a success).\n   */\n  status() {\n    return __classPrivateFieldGet(this, _HTTPResponse_status, \"f\");\n  }\n  /**\n   * @returns The status text of the response (e.g. usually an \"OK\" for a\n   * success).\n   */\n  statusText() {\n    return __classPrivateFieldGet(this, _HTTPResponse_statusText, \"f\");\n  }\n  /**\n   * @returns An object with HTTP headers associated with the response. All\n   * header names are lower-case.\n   */\n  headers() {\n    return __classPrivateFieldGet(this, _HTTPResponse_headers, \"f\");\n  }\n  /**\n   * @returns {@link SecurityDetails} if the response was received over the\n   * secure connection, or `null` otherwise.\n   */\n  securityDetails() {\n    return __classPrivateFieldGet(this, _HTTPResponse_securityDetails, \"f\");\n  }\n  /**\n   * @returns Timing information related to the response.\n   */\n  timing() {\n    return __classPrivateFieldGet(this, _HTTPResponse_timing, \"f\");\n  }\n  /**\n   * @returns Promise which resolves to a buffer with response body.\n   */\n  buffer() {\n    if (!__classPrivateFieldGet(this, _HTTPResponse_contentPromise, \"f\")) {\n      __classPrivateFieldSet(this, _HTTPResponse_contentPromise, __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromise, \"f\").then(async error => {\n        if (error) {\n          throw error;\n        }\n        try {\n          const response = await __classPrivateFieldGet(this, _HTTPResponse_client, \"f\").send('Network.getResponseBody', {\n            requestId: __classPrivateFieldGet(this, _HTTPResponse_request, \"f\")._requestId\n          });\n          return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n        } catch (error) {\n          if (error instanceof ProtocolError && error.originalMessage === 'No resource with given identifier found') {\n            throw new ProtocolError('Could not load body for this request. This might happen if the request is a preflight request.');\n          }\n          throw error;\n        }\n      }), \"f\");\n    }\n    return __classPrivateFieldGet(this, _HTTPResponse_contentPromise, \"f\");\n  }\n  /**\n   * @returns Promise which resolves to a text representation of response body.\n   */\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n  /**\n   *\n   * @returns Promise which resolves to a JSON representation of response body.\n   *\n   * @remarks\n   *\n   * This method will throw if the response body is not parsable via\n   * `JSON.parse`.\n   */\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  /**\n   * @returns A matching {@link HTTPRequest} object.\n   */\n  request() {\n    return __classPrivateFieldGet(this, _HTTPResponse_request, \"f\");\n  }\n  /**\n   * @returns True if the response was served from either the browser's disk\n   * cache or memory cache.\n   */\n  fromCache() {\n    return __classPrivateFieldGet(this, _HTTPResponse_fromDiskCache, \"f\") || __classPrivateFieldGet(this, _HTTPResponse_request, \"f\")._fromMemoryCache;\n  }\n  /**\n   * @returns True if the response was served by a service worker.\n   */\n  fromServiceWorker() {\n    return __classPrivateFieldGet(this, _HTTPResponse_fromServiceWorker, \"f\");\n  }\n  /**\n   * @returns A {@link Frame} that initiated this response, or `null` if\n   * navigating to error pages.\n   */\n  frame() {\n    return __classPrivateFieldGet(this, _HTTPResponse_request, \"f\").frame();\n  }\n}\n_HTTPResponse_client = new WeakMap(), _HTTPResponse_request = new WeakMap(), _HTTPResponse_contentPromise = new WeakMap(), _HTTPResponse_bodyLoadedPromise = new WeakMap(), _HTTPResponse_bodyLoadedPromiseFulfill = new WeakMap(), _HTTPResponse_remoteAddress = new WeakMap(), _HTTPResponse_status = new WeakMap(), _HTTPResponse_statusText = new WeakMap(), _HTTPResponse_url = new WeakMap(), _HTTPResponse_fromDiskCache = new WeakMap(), _HTTPResponse_fromServiceWorker = new WeakMap(), _HTTPResponse_headers = new WeakMap(), _HTTPResponse_securityDetails = new WeakMap(), _HTTPResponse_timing = new WeakMap(), _HTTPResponse_instances = new WeakSet(), _HTTPResponse_parseStatusTextFromExtrInfo = function _HTTPResponse_parseStatusTextFromExtrInfo(extraInfo) {\n  if (!extraInfo || !extraInfo.headersText) {\n    return;\n  }\n  const firstLine = extraInfo.headersText.split('\\r', 1)[0];\n  if (!firstLine) {\n    return;\n  }\n  const match = firstLine.match(/[^ ]* [^ ]* (.*)/);\n  if (!match) {\n    return;\n  }\n  const statusText = match[1];\n  if (!statusText) {\n    return;\n  }\n  return statusText;\n};","map":{"version":3,"mappings":"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","names":["SecurityDetails","ProtocolError","HTTPResponse","constructor","client","request","responsePayload","extraInfo","_HTTPResponse_client","_HTTPResponse_request","_HTTPResponse_contentPromise","_HTTPResponse_bodyLoadedPromise","_HTTPResponse_bodyLoadedPromiseFulfill","_HTTPResponse_remoteAddress","_HTTPResponse_status","_HTTPResponse_statusText","_HTTPResponse_url","_HTTPResponse_fromDiskCache","_HTTPResponse_fromServiceWorker","_HTTPResponse_headers","_HTTPResponse_securityDetails","_HTTPResponse_timing","__classPrivateFieldSet","Promise","fulfill","ip","remoteIPAddress","port","remotePort","__classPrivateFieldGet","statusText","url","fromDiskCache","fromServiceWorker","statusCode","status","headers","key","value","Object","entries","toLowerCase","securityDetails","timing","_resolveBody","err","remoteAddress","ok","buffer","then","error","response","send","requestId","_requestId","Buffer","from","body","base64Encoded","originalMessage","text","content","toString","json","JSON","parse","fromCache","_fromMemoryCache","frame","headersText","firstLine","split","match"],"sources":["../../../../src/common/HTTPResponse.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}