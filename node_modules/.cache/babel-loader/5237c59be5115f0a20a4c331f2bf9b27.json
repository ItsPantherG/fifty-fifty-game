{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _WaitTask_world, _WaitTask_bindings, _WaitTask_polling, _WaitTask_root, _WaitTask_fn, _WaitTask_args, _WaitTask_timeout, _WaitTask_result, _WaitTask_poller, _TaskManager_tasks;\nimport { createDeferredPromise } from '../util/DeferredPromise.js';\nimport { TimeoutError } from './Errors.js';\n/**\n * @internal\n */\nexport class WaitTask {\n  constructor(world, options, fn) {\n    var _a;\n    _WaitTask_world.set(this, void 0);\n    _WaitTask_bindings.set(this, void 0);\n    _WaitTask_polling.set(this, void 0);\n    _WaitTask_root.set(this, void 0);\n    _WaitTask_fn.set(this, void 0);\n    _WaitTask_args.set(this, void 0);\n    _WaitTask_timeout.set(this, void 0);\n    _WaitTask_result.set(this, createDeferredPromise());\n    _WaitTask_poller.set(this, void 0);\n    __classPrivateFieldSet(this, _WaitTask_world, world, \"f\");\n    __classPrivateFieldSet(this, _WaitTask_bindings, (_a = options.bindings) !== null && _a !== void 0 ? _a : new Map(), \"f\");\n    __classPrivateFieldSet(this, _WaitTask_polling, options.polling, \"f\");\n    __classPrivateFieldSet(this, _WaitTask_root, options.root, \"f\");\n    switch (typeof fn) {\n      case 'string':\n        __classPrivateFieldSet(this, _WaitTask_fn, `() => {return (${fn});}`, \"f\");\n        break;\n      default:\n        __classPrivateFieldSet(this, _WaitTask_fn, fn.toString(), \"f\");\n        break;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n    __classPrivateFieldSet(this, _WaitTask_args, args, \"f\");\n    __classPrivateFieldGet(this, _WaitTask_world, \"f\").taskManager.add(this);\n    if (options.timeout) {\n      __classPrivateFieldSet(this, _WaitTask_timeout, setTimeout(() => {\n        this.terminate(new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));\n      }, options.timeout), \"f\");\n    }\n    if (__classPrivateFieldGet(this, _WaitTask_bindings, \"f\").size !== 0) {\n      for (const [name, fn] of __classPrivateFieldGet(this, _WaitTask_bindings, \"f\")) {\n        __classPrivateFieldGet(this, _WaitTask_world, \"f\")._boundFunctions.set(name, fn);\n      }\n    }\n    this.rerun();\n  }\n  get result() {\n    return __classPrivateFieldGet(this, _WaitTask_result, \"f\");\n  }\n  async rerun() {\n    try {\n      if (__classPrivateFieldGet(this, _WaitTask_bindings, \"f\").size !== 0) {\n        const context = await __classPrivateFieldGet(this, _WaitTask_world, \"f\").executionContext();\n        await Promise.all([...__classPrivateFieldGet(this, _WaitTask_bindings, \"f\")].map(async _ref => {\n          let [name] = _ref;\n          return await __classPrivateFieldGet(this, _WaitTask_world, \"f\")._addBindingToContext(context, name);\n        }));\n      }\n      switch (__classPrivateFieldGet(this, _WaitTask_polling, \"f\")) {\n        case 'raf':\n          __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").evaluateHandle(function (_ref2, fn) {\n            let {\n              RAFPoller,\n              createFunction\n            } = _ref2;\n            for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n              args[_key2 - 2] = arguments[_key2];\n            }\n            const fun = createFunction(fn);\n            return new RAFPoller(() => {\n              return fun(...args);\n            });\n          }, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_fn, \"f\"), ...__classPrivateFieldGet(this, _WaitTask_args, \"f\")), \"f\");\n          break;\n        case 'mutation':\n          __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").evaluateHandle(function (_ref3, root, fn) {\n            let {\n              MutationPoller,\n              createFunction\n            } = _ref3;\n            for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n              args[_key3 - 3] = arguments[_key3];\n            }\n            const fun = createFunction(fn);\n            return new MutationPoller(() => {\n              return fun(...args);\n            }, root || document);\n          }, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_root, \"f\"), __classPrivateFieldGet(this, _WaitTask_fn, \"f\"), ...__classPrivateFieldGet(this, _WaitTask_args, \"f\")), \"f\");\n          break;\n        default:\n          __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").evaluateHandle(function (_ref4, ms, fn) {\n            let {\n              IntervalPoller,\n              createFunction\n            } = _ref4;\n            for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n              args[_key4 - 3] = arguments[_key4];\n            }\n            const fun = createFunction(fn);\n            return new IntervalPoller(() => {\n              return fun(...args);\n            }, ms);\n          }, await __classPrivateFieldGet(this, _WaitTask_world, \"f\").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_polling, \"f\"), __classPrivateFieldGet(this, _WaitTask_fn, \"f\"), ...__classPrivateFieldGet(this, _WaitTask_args, \"f\")), \"f\");\n          break;\n      }\n      await __classPrivateFieldGet(this, _WaitTask_poller, \"f\").evaluate(poller => {\n        poller.start();\n      });\n      const result = await __classPrivateFieldGet(this, _WaitTask_poller, \"f\").evaluateHandle(poller => {\n        return poller.result();\n      });\n      __classPrivateFieldGet(this, _WaitTask_result, \"f\").resolve(result);\n      await this.terminate();\n    } catch (error) {\n      const badError = this.getBadError(error);\n      if (badError) {\n        await this.terminate(badError);\n      }\n    }\n  }\n  async terminate(error) {\n    __classPrivateFieldGet(this, _WaitTask_world, \"f\").taskManager.delete(this);\n    if (__classPrivateFieldGet(this, _WaitTask_timeout, \"f\")) {\n      clearTimeout(__classPrivateFieldGet(this, _WaitTask_timeout, \"f\"));\n    }\n    if (error && !__classPrivateFieldGet(this, _WaitTask_result, \"f\").finished()) {\n      __classPrivateFieldGet(this, _WaitTask_result, \"f\").reject(error);\n    }\n    if (__classPrivateFieldGet(this, _WaitTask_poller, \"f\")) {\n      try {\n        await __classPrivateFieldGet(this, _WaitTask_poller, \"f\").evaluateHandle(async poller => {\n          await poller.stop();\n        });\n        if (__classPrivateFieldGet(this, _WaitTask_poller, \"f\")) {\n          await __classPrivateFieldGet(this, _WaitTask_poller, \"f\").dispose();\n          __classPrivateFieldSet(this, _WaitTask_poller, undefined, \"f\");\n        }\n      } catch {\n        // Ignore errors since they most likely come from low-level cleanup.\n      }\n    }\n  }\n  /**\n   * Not all errors lead to termination. They usually imply we need to rerun the task.\n   */\n  getBadError(error) {\n    if (error instanceof Error) {\n      // When frame is detached the task should have been terminated by the IsolatedWorld.\n      // This can fail if we were adding this task while the frame was detached,\n      // so we terminate here instead.\n      if (error.message.includes('Execution context is not available in detached frame')) {\n        return new Error('Waiting failed: Frame detached');\n      }\n      // When the page is navigated, the promise is rejected.\n      // We will try again in the new execution context.\n      if (error.message.includes('Execution context was destroyed')) {\n        return;\n      }\n      // We could have tried to evaluate in a context which was already\n      // destroyed.\n      if (error.message.includes('Cannot find context with specified id')) {\n        return;\n      }\n    }\n    return error;\n  }\n}\n_WaitTask_world = new WeakMap(), _WaitTask_bindings = new WeakMap(), _WaitTask_polling = new WeakMap(), _WaitTask_root = new WeakMap(), _WaitTask_fn = new WeakMap(), _WaitTask_args = new WeakMap(), _WaitTask_timeout = new WeakMap(), _WaitTask_result = new WeakMap(), _WaitTask_poller = new WeakMap();\n/**\n * @internal\n */\nexport class TaskManager {\n  constructor() {\n    _TaskManager_tasks.set(this, new Set());\n  }\n  add(task) {\n    __classPrivateFieldGet(this, _TaskManager_tasks, \"f\").add(task);\n  }\n  delete(task) {\n    __classPrivateFieldGet(this, _TaskManager_tasks, \"f\").delete(task);\n  }\n  terminateAll(error) {\n    for (const task of __classPrivateFieldGet(this, _TaskManager_tasks, \"f\")) {\n      task.terminate(error);\n    }\n    __classPrivateFieldGet(this, _TaskManager_tasks, \"f\").clear();\n  }\n  async rerunAll() {\n    await Promise.all([...__classPrivateFieldGet(this, _TaskManager_tasks, \"f\")].map(task => {\n      return task.rerun();\n    }));\n  }\n}\n_TaskManager_tasks = new WeakMap();","map":{"version":3,"mappings":"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","names":["createDeferredPromise","TimeoutError","WaitTask","constructor","world","options","fn","_WaitTask_world","_WaitTask_bindings","_WaitTask_polling","_WaitTask_root","_WaitTask_fn","_WaitTask_args","_WaitTask_timeout","_WaitTask_result","_WaitTask_poller","__classPrivateFieldSet","bindings","Map","polling","root","toString","args","__classPrivateFieldGet","taskManager","add","timeout","setTimeout","terminate","size","name","_boundFunctions","set","rerun","result","context","executionContext","Promise","all","map","_addBindingToContext","evaluateHandle","RAFPoller","createFunction","fun","puppeteerUtil","MutationPoller","document","ms","IntervalPoller","evaluate","poller","start","resolve","error","badError","getBadError","delete","clearTimeout","finished","reject","stop","dispose","undefined","Error","message","includes","TaskManager","_TaskManager_tasks","Set","task","terminateAll","clear","rerunAll"],"sources":["../../../../src/common/WaitTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}