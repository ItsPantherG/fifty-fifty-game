{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HTTPRequest_instances, _HTTPRequest_client, _HTTPRequest_isNavigationRequest, _HTTPRequest_allowInterception, _HTTPRequest_interceptionHandled, _HTTPRequest_url, _HTTPRequest_resourceType, _HTTPRequest_method, _HTTPRequest_postData, _HTTPRequest_headers, _HTTPRequest_frame, _HTTPRequest_continueRequestOverrides, _HTTPRequest_responseForRequest, _HTTPRequest_abortErrorReason, _HTTPRequest_interceptResolutionState, _HTTPRequest_interceptHandlers, _HTTPRequest_initiator, _HTTPRequest_continue, _HTTPRequest_respond, _HTTPRequest_abort;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InterceptResolutionAction = exports.HTTPRequest = exports.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = void 0;\nconst assert_js_1 = require(\"../util/assert.js\");\nconst util_js_1 = require(\"./util.js\");\n/**\n * The default cooperative request interception resolution priority\n *\n * @public\n */\nexports.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;\n/**\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`: emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\nclass HTTPRequest {\n  /**\n   * @internal\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    _HTTPRequest_instances.add(this);\n    /**\n     * @internal\n     */\n    this._failureText = null;\n    /**\n     * @internal\n     */\n    this._response = null;\n    /**\n     * @internal\n     */\n    this._fromMemoryCache = false;\n    _HTTPRequest_client.set(this, void 0);\n    _HTTPRequest_isNavigationRequest.set(this, void 0);\n    _HTTPRequest_allowInterception.set(this, void 0);\n    _HTTPRequest_interceptionHandled.set(this, false);\n    _HTTPRequest_url.set(this, void 0);\n    _HTTPRequest_resourceType.set(this, void 0);\n    _HTTPRequest_method.set(this, void 0);\n    _HTTPRequest_postData.set(this, void 0);\n    _HTTPRequest_headers.set(this, {});\n    _HTTPRequest_frame.set(this, void 0);\n    _HTTPRequest_continueRequestOverrides.set(this, void 0);\n    _HTTPRequest_responseForRequest.set(this, null);\n    _HTTPRequest_abortErrorReason.set(this, null);\n    _HTTPRequest_interceptResolutionState.set(this, {\n      action: InterceptResolutionAction.None\n    });\n    _HTTPRequest_interceptHandlers.set(this, void 0);\n    _HTTPRequest_initiator.set(this, void 0);\n    __classPrivateFieldSet(this, _HTTPRequest_client, client, \"f\");\n    this._requestId = event.requestId;\n    __classPrivateFieldSet(this, _HTTPRequest_isNavigationRequest, event.requestId === event.loaderId && event.type === 'Document', \"f\");\n    this._interceptionId = interceptionId;\n    __classPrivateFieldSet(this, _HTTPRequest_allowInterception, allowInterception, \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_url, event.request.url, \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_resourceType, (event.type || 'other').toLowerCase(), \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_method, event.request.method, \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_postData, event.request.postData, \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_frame, frame, \"f\");\n    this._redirectChain = redirectChain;\n    __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, {}, \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_interceptHandlers, [], \"f\");\n    __classPrivateFieldSet(this, _HTTPRequest_initiator, event.initiator, \"f\");\n    for (const [key, value] of Object.entries(event.request.headers)) {\n      __classPrivateFieldGet(this, _HTTPRequest_headers, \"f\")[key.toLowerCase()] = value;\n    }\n  }\n  /**\n   * Warning! Using this client can break Puppeteer. Use with caution.\n   *\n   * @experimental\n   */\n  get client() {\n    return __classPrivateFieldGet(this, _HTTPRequest_client, \"f\");\n  }\n  /**\n   * @returns the URL of the request\n   */\n  url() {\n    return __classPrivateFieldGet(this, _HTTPRequest_url, \"f\");\n  }\n  /**\n   * @returns the `ContinueRequestOverrides` that will be used\n   * if the interception is allowed to continue (ie, `abort()` and\n   * `respond()` aren't called).\n   */\n  continueRequestOverrides() {\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    return __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, \"f\");\n  }\n  /**\n   * @returns The `ResponseForRequest` that gets used if the\n   * interception is allowed to respond (ie, `abort()` is not called).\n   */\n  responseForRequest() {\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    return __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, \"f\");\n  }\n  /**\n   * @returns the most recent reason for aborting the request\n   */\n  abortErrorReason() {\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    return __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, \"f\");\n  }\n  /**\n   * @returns An InterceptResolutionState object describing the current resolution\n   * action and priority.\n   *\n   * InterceptResolutionState contains:\n   * action: InterceptResolutionAction\n   * priority?: number\n   *\n   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,\n   * `disabled`, `none`, or `already-handled`.\n   */\n  interceptResolutionState() {\n    if (!__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\")) {\n      return {\n        action: InterceptResolutionAction.Disabled\n      };\n    }\n    if (__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, \"f\")) {\n      return {\n        action: InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\")\n    };\n  }\n  /**\n   * @returns `true` if the intercept resolution has already been handled,\n   * `false` otherwise.\n   */\n  isInterceptResolutionHandled() {\n    return __classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, \"f\");\n  }\n  /**\n   * Adds an async request handler to the processing queue.\n   * Deferred handlers are not guaranteed to execute in any particular order,\n   * but they are guaranteed to resolve before the request interception\n   * is finalized.\n   */\n  enqueueInterceptAction(pendingHandler) {\n    __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, \"f\").push(pendingHandler);\n  }\n  /**\n   * Awaits pending interception handlers and then decides how to fulfill\n   * the request interception.\n   */\n  async finalizeInterceptions() {\n    await __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, \"f\").reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_abort).call(this, __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, \"f\"));\n      case 'respond':\n        if (__classPrivateFieldGet(this, _HTTPRequest_responseForRequest, \"f\") === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_respond).call(this, __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, \"f\"));\n      case 'continue':\n        return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_continue).call(this, __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, \"f\"));\n    }\n  }\n  /**\n   * Contains the request's resource type as it was perceived by the rendering\n   * engine.\n   */\n  resourceType() {\n    return __classPrivateFieldGet(this, _HTTPRequest_resourceType, \"f\");\n  }\n  /**\n   * @returns the method used (`GET`, `POST`, etc.)\n   */\n  method() {\n    return __classPrivateFieldGet(this, _HTTPRequest_method, \"f\");\n  }\n  /**\n   * @returns the request's post body, if any.\n   */\n  postData() {\n    return __classPrivateFieldGet(this, _HTTPRequest_postData, \"f\");\n  }\n  /**\n   * @returns an object with HTTP headers associated with the request. All\n   * header names are lower-case.\n   */\n  headers() {\n    return __classPrivateFieldGet(this, _HTTPRequest_headers, \"f\");\n  }\n  /**\n   * @returns A matching `HTTPResponse` object, or null if the response has not\n   * been received yet.\n   */\n  response() {\n    return this._response;\n  }\n  /**\n   * @returns the frame that initiated the request, or null if navigating to\n   * error pages.\n   */\n  frame() {\n    return __classPrivateFieldGet(this, _HTTPRequest_frame, \"f\");\n  }\n  /**\n   * @returns true if the request is the driver of the current frame's navigation.\n   */\n  isNavigationRequest() {\n    return __classPrivateFieldGet(this, _HTTPRequest_isNavigationRequest, \"f\");\n  }\n  /**\n   * @returns the initiator of the request.\n   */\n  initiator() {\n    return __classPrivateFieldGet(this, _HTTPRequest_initiator, \"f\");\n  }\n  /**\n   * A `redirectChain` is a chain of requests initiated to fetch a resource.\n   * @remarks\n   *\n   * `redirectChain` is shared between all the requests of the same chain.\n   *\n   * For example, if the website `http://example.com` has a single redirect to\n   * `https://example.com`, then the chain will contain one request:\n   *\n   * ```ts\n   * const response = await page.goto('http://example.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 1\n   * console.log(chain[0].url()); // 'http://example.com'\n   * ```\n   *\n   * If the website `https://google.com` has no redirects, then the chain will be empty:\n   *\n   * ```ts\n   * const response = await page.goto('https://google.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 0\n   * ```\n   *\n   * @returns the chain of requests - if a server responds with at least a\n   * single redirect, this chain will contain all requests that were redirected.\n   */\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  /**\n   * Access information about the request's failure.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * Example of logging all failed requests:\n   *\n   * ```ts\n   * page.on('requestfailed', request => {\n   *   console.log(request.url() + ' ' + request.failure().errorText);\n   * });\n   * ```\n   *\n   * @returns `null` unless the request failed. If the request fails this can\n   * return an object with `errorText` containing a human-readable error\n   * message, e.g. `net::ERR_FAILED`. It is not guaranteed that there will be\n   * failure text if the request fails.\n   */\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * Continues request with optional request overrides.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   // Override headers\n   *   const headers = Object.assign({}, request.headers(), {\n   *     foo: 'bar', // set \"foo\" header\n   *     origin: undefined, // remove \"origin\" header\n   *   });\n   *   request.continue({headers});\n   * });\n   * ```\n   *\n   * @param overrides - optional overrides to apply to the request.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n  async continue() {\n    let overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let priority = arguments.length > 1 ? arguments[1] : undefined;\n    // Request interception is not supported for data: urls.\n    if (__classPrivateFieldGet(this, _HTTPRequest_url, \"f\").startsWith('data:')) {\n      return;\n    }\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, \"f\"), 'Request is already handled!');\n    if (priority === undefined) {\n      return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_continue).call(this, overrides);\n    }\n    __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, overrides, \"f\");\n    if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority === undefined || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority) {\n      __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {\n        action: InterceptResolutionAction.Continue,\n        priority\n      }, \"f\");\n      return;\n    }\n    if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority) {\n      if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").action === 'abort' || __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").action === 'respond') {\n        return;\n      }\n      __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").action = InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  /**\n   * Fulfills a request with the given response.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   * An example of fulfilling all requests with 404 responses:\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   request.respond({\n   *     status: 404,\n   *     contentType: 'text/plain',\n   *     body: 'Not Found!',\n   *   });\n   * });\n   * ```\n   *\n   * NOTE: Mocking responses for dataURL requests is not supported.\n   * Calling `request.respond` for a dataURL request is a noop.\n   *\n   * @param response - the response to fulfill the request with.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (__classPrivateFieldGet(this, _HTTPRequest_url, \"f\").startsWith('data:')) {\n      return;\n    }\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, \"f\"), 'Request is already handled!');\n    if (priority === undefined) {\n      return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_respond).call(this, response);\n    }\n    __classPrivateFieldSet(this, _HTTPRequest_responseForRequest, response, \"f\");\n    if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority === undefined || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority) {\n      __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {\n        action: InterceptResolutionAction.Respond,\n        priority\n      }, \"f\");\n      return;\n    }\n    if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority) {\n      if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").action === 'abort') {\n        return;\n      }\n      __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").action = InterceptResolutionAction.Respond;\n    }\n  }\n  /**\n   * Aborts a request.\n   *\n   * @remarks\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}. If it is not enabled, this method will\n   * throw an exception immediately.\n   *\n   * @param errorCode - optional error code to provide.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n  async abort() {\n    let errorCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'failed';\n    let priority = arguments.length > 1 ? arguments[1] : undefined;\n    // Request interception is not supported for data: urls.\n    if (__classPrivateFieldGet(this, _HTTPRequest_url, \"f\").startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    (0, assert_js_1.assert)(errorReason, 'Unknown error code: ' + errorCode);\n    (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, \"f\"), 'Request Interception is not enabled!');\n    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, \"f\"), 'Request is already handled!');\n    if (priority === undefined) {\n      return __classPrivateFieldGet(this, _HTTPRequest_instances, \"m\", _HTTPRequest_abort).call(this, errorReason);\n    }\n    __classPrivateFieldSet(this, _HTTPRequest_abortErrorReason, errorReason, \"f\");\n    if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority === undefined || priority >= __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, \"f\").priority) {\n      __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {\n        action: InterceptResolutionAction.Abort,\n        priority\n      }, \"f\");\n      return;\n    }\n  }\n}\nexports.HTTPRequest = HTTPRequest;\n_HTTPRequest_client = new WeakMap(), _HTTPRequest_isNavigationRequest = new WeakMap(), _HTTPRequest_allowInterception = new WeakMap(), _HTTPRequest_interceptionHandled = new WeakMap(), _HTTPRequest_url = new WeakMap(), _HTTPRequest_resourceType = new WeakMap(), _HTTPRequest_method = new WeakMap(), _HTTPRequest_postData = new WeakMap(), _HTTPRequest_headers = new WeakMap(), _HTTPRequest_frame = new WeakMap(), _HTTPRequest_continueRequestOverrides = new WeakMap(), _HTTPRequest_responseForRequest = new WeakMap(), _HTTPRequest_abortErrorReason = new WeakMap(), _HTTPRequest_interceptResolutionState = new WeakMap(), _HTTPRequest_interceptHandlers = new WeakMap(), _HTTPRequest_initiator = new WeakMap(), _HTTPRequest_instances = new WeakSet(), _HTTPRequest_continue = async function _HTTPRequest_continue() {\n  let overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    url,\n    method,\n    postData,\n    headers\n  } = overrides;\n  __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, \"f\");\n  const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n  if (this._interceptionId === undefined) {\n    throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n  }\n  await __classPrivateFieldGet(this, _HTTPRequest_client, \"f\").send('Fetch.continueRequest', {\n    requestId: this._interceptionId,\n    url,\n    method,\n    postData: postDataBinaryBase64,\n    headers: headers ? headersArray(headers) : undefined\n  }).catch(error => {\n    __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, \"f\");\n    return handleError(error);\n  });\n}, _HTTPRequest_respond = async function _HTTPRequest_respond(response) {\n  __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, \"f\");\n  const responseBody = response.body && (0, util_js_1.isString)(response.body) ? Buffer.from(response.body) : response.body || null;\n  const responseHeaders = {};\n  if (response.headers) {\n    for (const header of Object.keys(response.headers)) {\n      const value = response.headers[header];\n      responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n        return String(item);\n      }) : String(value);\n    }\n  }\n  if (response.contentType) {\n    responseHeaders['content-type'] = response.contentType;\n  }\n  if (responseBody && !('content-length' in responseHeaders)) {\n    responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n  }\n  const status = response.status || 200;\n  if (this._interceptionId === undefined) {\n    throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n  }\n  await __classPrivateFieldGet(this, _HTTPRequest_client, \"f\").send('Fetch.fulfillRequest', {\n    requestId: this._interceptionId,\n    responseCode: status,\n    responsePhrase: STATUS_TEXTS[status],\n    responseHeaders: headersArray(responseHeaders),\n    body: responseBody ? responseBody.toString('base64') : undefined\n  }).catch(error => {\n    __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, \"f\");\n    return handleError(error);\n  });\n}, _HTTPRequest_abort = async function _HTTPRequest_abort(errorReason) {\n  __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, \"f\");\n  if (this._interceptionId === undefined) {\n    throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n  }\n  await __classPrivateFieldGet(this, _HTTPRequest_client, \"f\").send('Fetch.failRequest', {\n    requestId: this._interceptionId,\n    errorReason: errorReason || 'Failed'\n  }).catch(handleError);\n};\n/**\n * @public\n */\nvar InterceptResolutionAction;\n(function (InterceptResolutionAction) {\n  InterceptResolutionAction[\"Abort\"] = \"abort\";\n  InterceptResolutionAction[\"Respond\"] = \"respond\";\n  InterceptResolutionAction[\"Continue\"] = \"continue\";\n  InterceptResolutionAction[\"Disabled\"] = \"disabled\";\n  InterceptResolutionAction[\"None\"] = \"none\";\n  InterceptResolutionAction[\"AlreadyHandled\"] = \"already-handled\";\n})(InterceptResolutionAction = exports.InterceptResolutionAction || (exports.InterceptResolutionAction = {}));\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\nfunction headersArray(headers) {\n  const result = [];\n  for (const name in headers) {\n    const value = headers[name];\n    if (!Object.is(value, undefined)) {\n      const values = Array.isArray(value) ? value : [value];\n      result.push(...values.map(value => {\n        return {\n          name,\n          value: value + ''\n        };\n      }));\n    }\n  }\n  return result;\n}\nasync function handleError(error) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  (0, util_js_1.debugError)(error);\n}\n// List taken from\n// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n// with extra 306 and 418 codes.\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': \"I'm a teapot\",\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};","map":{"version":3,"mappings":"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","names":["exports","HTTPRequest","constructor","client","frame","interceptionId","allowInterception","event","redirectChain","_HTTPRequest_client","_HTTPRequest_isNavigationRequest","_HTTPRequest_allowInterception","_HTTPRequest_interceptionHandled","_HTTPRequest_url","_HTTPRequest_resourceType","_HTTPRequest_method","_HTTPRequest_postData","_HTTPRequest_headers","_HTTPRequest_frame","_HTTPRequest_continueRequestOverrides","_HTTPRequest_responseForRequest","_HTTPRequest_abortErrorReason","_HTTPRequest_interceptResolutionState","action","InterceptResolutionAction","None","_HTTPRequest_interceptHandlers","_HTTPRequest_initiator","__classPrivateFieldSet","_requestId","requestId","loaderId","type","_interceptionId","request","url","toLowerCase","method","postData","_redirectChain","initiator","key","value","Object","entries","headers","__classPrivateFieldGet","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","Error","resourceType","response","_response","isNavigationRequest","slice","failure","_failureText","errorText","continue","overrides","priority","startsWith","undefined","Continue","respond","Respond","abort","errorCode","errorReason","errorReasons","Abort","_HTTPRequest_continue","postDataBinaryBase64","Buffer","from","toString","send","headersArray","catch","error","handleError","_HTTPRequest_respond","responseBody","body","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","byteLength","status","responseCode","responsePhrase","STATUS_TEXTS","_HTTPRequest_abort","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","result","name","is","values","includes","originalMessage"],"sources":["../../../../src/common/HTTPRequest.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}