{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _NetworkManager_instances, _NetworkManager_client, _NetworkManager_ignoreHTTPSErrors, _NetworkManager_frameManager, _NetworkManager_networkEventManager, _NetworkManager_extraHTTPHeaders, _NetworkManager_credentials, _NetworkManager_attemptedAuthentications, _NetworkManager_userRequestInterceptionEnabled, _NetworkManager_protocolRequestInterceptionEnabled, _NetworkManager_userCacheDisabled, _NetworkManager_emulatedNetworkConditions, _NetworkManager_deferredInitPromise, _NetworkManager_updateNetworkConditions, _NetworkManager_updateProtocolRequestInterception, _NetworkManager_cacheDisabled, _NetworkManager_updateProtocolCacheDisabled, _NetworkManager_onRequestWillBeSent, _NetworkManager_onAuthRequired, _NetworkManager_onRequestPaused, _NetworkManager_patchRequestEventHeaders, _NetworkManager_onRequest, _NetworkManager_onRequestServedFromCache, _NetworkManager_handleRequestRedirect, _NetworkManager_emitResponseEvent, _NetworkManager_onResponseReceived, _NetworkManager_onResponseReceivedExtraInfo, _NetworkManager_forgetRequest, _NetworkManager_onLoadingFinished, _NetworkManager_emitLoadingFinished, _NetworkManager_onLoadingFailed, _NetworkManager_emitLoadingFailed;\nimport { assert } from '../util/assert.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\nimport { NetworkEventManager } from './NetworkEventManager.js';\nimport { debugError, isString } from './util.js';\nimport { createDebuggableDeferredPromise } from '../util/DebuggableDeferredPromise.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    _NetworkManager_instances.add(this);\n    _NetworkManager_client.set(this, void 0);\n    _NetworkManager_ignoreHTTPSErrors.set(this, void 0);\n    _NetworkManager_frameManager.set(this, void 0);\n    _NetworkManager_networkEventManager.set(this, new NetworkEventManager());\n    _NetworkManager_extraHTTPHeaders.set(this, {});\n    _NetworkManager_credentials.set(this, void 0);\n    _NetworkManager_attemptedAuthentications.set(this, new Set());\n    _NetworkManager_userRequestInterceptionEnabled.set(this, false);\n    _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);\n    _NetworkManager_userCacheDisabled.set(this, false);\n    _NetworkManager_emulatedNetworkConditions.set(this, {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    });\n    _NetworkManager_deferredInitPromise.set(this, void 0);\n    __classPrivateFieldSet(this, _NetworkManager_client, client, \"f\");\n    __classPrivateFieldSet(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, \"f\");\n    __classPrivateFieldSet(this, _NetworkManager_frameManager, frameManager, \"f\");\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.requestPaused', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestPaused).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.authRequired', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onAuthRequired).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestWillBeSent', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestWillBeSent).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestServedFromCache', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestServedFromCache).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceived', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceived).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFinished', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFinished).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFailed', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFailed).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceivedExtraInfo', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceivedExtraInfo).bind(this));\n  }\n  /**\n   * Initialize calls should avoid async dependencies between CDP calls as those\n   * might not resolve until after the target is resumed causing a deadlock.\n   */\n  initialize() {\n    if (__classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\")) {\n      return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n    }\n    __classPrivateFieldSet(this, _NetworkManager_deferredInitPromise, createDebuggableDeferredPromise('NetworkManager initialization timed out'), \"f\");\n    const init = Promise.all([__classPrivateFieldGet(this, _NetworkManager_ignoreHTTPSErrors, \"f\") ? __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    }) : null, __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.enable')]);\n    const deferredInitPromise = __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n    init.then(() => {\n      deferredInitPromise.resolve();\n    }).catch(err => {\n      deferredInitPromise.reject(err);\n    });\n    return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n  }\n  async authenticate(credentials) {\n    __classPrivateFieldSet(this, _NetworkManager_credentials, credentials, \"f\");\n    await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(this);\n  }\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    __classPrivateFieldSet(this, _NetworkManager_extraHTTPHeaders, {}, \"f\");\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\")[key.toLowerCase()] = value;\n    }\n    await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setExtraHTTPHeaders', {\n      headers: __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\")\n    });\n  }\n  extraHTTPHeaders() {\n    return Object.assign({}, __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\"));\n  }\n  numRequestsInProgress() {\n    return __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").numRequestsInProgress();\n  }\n  async setOfflineMode(value) {\n    __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").offline = value;\n    await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(this);\n  }\n  async emulateNetworkConditions(networkConditions) {\n    __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").upload = networkConditions ? networkConditions.upload : -1;\n    __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").download = networkConditions ? networkConditions.download : -1;\n    __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").latency = networkConditions ? networkConditions.latency : 0;\n    await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(this);\n  }\n  async setUserAgent(userAgent, userAgentMetadata) {\n    await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setUserAgentOverride', {\n      userAgent: userAgent,\n      userAgentMetadata: userAgentMetadata\n    });\n  }\n  async setCacheEnabled(enabled) {\n    __classPrivateFieldSet(this, _NetworkManager_userCacheDisabled, !enabled, \"f\");\n    await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this);\n  }\n  async setRequestInterception(value) {\n    __classPrivateFieldSet(this, _NetworkManager_userRequestInterceptionEnabled, value, \"f\");\n    await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(this);\n  }\n}\n_NetworkManager_client = new WeakMap(), _NetworkManager_ignoreHTTPSErrors = new WeakMap(), _NetworkManager_frameManager = new WeakMap(), _NetworkManager_networkEventManager = new WeakMap(), _NetworkManager_extraHTTPHeaders = new WeakMap(), _NetworkManager_credentials = new WeakMap(), _NetworkManager_attemptedAuthentications = new WeakMap(), _NetworkManager_userRequestInterceptionEnabled = new WeakMap(), _NetworkManager_protocolRequestInterceptionEnabled = new WeakMap(), _NetworkManager_userCacheDisabled = new WeakMap(), _NetworkManager_emulatedNetworkConditions = new WeakMap(), _NetworkManager_deferredInitPromise = new WeakMap(), _NetworkManager_instances = new WeakSet(), _NetworkManager_updateNetworkConditions = async function _NetworkManager_updateNetworkConditions() {\n  await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.emulateNetworkConditions', {\n    offline: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").offline,\n    latency: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").latency,\n    uploadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").upload,\n    downloadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").download\n  });\n}, _NetworkManager_updateProtocolRequestInterception = async function _NetworkManager_updateProtocolRequestInterception() {\n  const enabled = __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") || !!__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\");\n  if (enabled === __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n    return;\n  }\n  __classPrivateFieldSet(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, \"f\");\n  if (enabled) {\n    await Promise.all([__classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this), __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.enable', {\n      handleAuthRequests: true,\n      patterns: [{\n        urlPattern: '*'\n      }]\n    })]);\n  } else {\n    await Promise.all([__classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this), __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.disable')]);\n  }\n}, _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled() {\n  return __classPrivateFieldGet(this, _NetworkManager_userCacheDisabled, \"f\");\n}, _NetworkManager_updateProtocolCacheDisabled = async function _NetworkManager_updateProtocolCacheDisabled() {\n  await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setCacheDisabled', {\n    cacheDisabled: __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_cacheDisabled).call(this)\n  });\n}, _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent(event) {\n  // Request interception doesn't happen for data URLs with Network Service.\n  if (__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") && !event.request.url.startsWith('data:')) {\n    const {\n      requestId: networkRequestId\n    } = event;\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestWillBeSent(networkRequestId, event);\n    /**\n     * CDP may have sent a Fetch.requestPaused event already. Check for it.\n     */\n    const requestPausedEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestPaused(networkRequestId);\n    if (requestPausedEvent) {\n      const {\n        requestId: fetchRequestId\n      } = requestPausedEvent;\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, fetchRequestId);\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestPaused(networkRequestId);\n    }\n    return;\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, undefined);\n}, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired(event) {\n  let response = 'Default';\n  if (__classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").has(event.requestId)) {\n    response = 'CancelAuth';\n  } else if (__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\")) {\n    response = 'ProvideCredentials';\n    __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").add(event.requestId);\n  }\n  const {\n    username,\n    password\n  } = __classPrivateFieldGet(this, _NetworkManager_credentials, \"f\") || {\n    username: undefined,\n    password: undefined\n  };\n  __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.continueWithAuth', {\n    requestId: event.requestId,\n    authChallengeResponse: {\n      response,\n      username,\n      password\n    }\n  }).catch(debugError);\n}, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused(event) {\n  if (!__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") && __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.continueRequest', {\n      requestId: event.requestId\n    }).catch(debugError);\n  }\n  const {\n    networkId: networkRequestId,\n    requestId: fetchRequestId\n  } = event;\n  if (!networkRequestId) {\n    return;\n  }\n  const requestWillBeSentEvent = (() => {\n    const requestWillBeSentEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestWillBeSent(networkRequestId);\n    // redirect requests have the same `requestId`,\n    if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestWillBeSent(networkRequestId);\n      return;\n    }\n    return requestWillBeSentEvent;\n  })();\n  if (requestWillBeSentEvent) {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestPaused(networkRequestId, event);\n  }\n}, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {\n  requestWillBeSentEvent.request.headers = {\n    ...requestWillBeSentEvent.request.headers,\n    // includes extra headers, like: Accept, Origin\n    ...requestPausedEvent.request.headers\n  };\n}, _NetworkManager_onRequest = function _NetworkManager_onRequest(event, fetchRequestId) {\n  let redirectChain = [];\n  if (event.redirectResponse) {\n    // We want to emit a response and requestfinished for the\n    // redirectResponse, but we can't do so unless we have a\n    // responseExtraInfo ready to pair it up with. If we don't have any\n    // responseExtraInfos saved in our queue, they we have to wait until\n    // the next one to emit response and requestfinished, *and* we should\n    // also wait to emit this Request too because it should come after the\n    // response/requestfinished.\n    let redirectResponseExtraInfo = null;\n    if (event.redirectHasExtraInfo) {\n      redirectResponseExtraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).shift();\n      if (!redirectResponseExtraInfo) {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueRedirectInfo(event.requestId, {\n          event,\n          fetchRequestId\n        });\n        return;\n      }\n    }\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    // If we connect late to the target, we could have missed the\n    // requestWillBeSent event.\n    if (request) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_handleRequestRedirect).call(this, request, event.redirectResponse, redirectResponseExtraInfo);\n      redirectChain = request._redirectChain;\n    }\n  }\n  const frame = event.frameId ? __classPrivateFieldGet(this, _NetworkManager_frameManager, \"f\").frame(event.frameId) : null;\n  const request = new HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), frame, fetchRequestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\"), event, redirectChain);\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequest(event.requestId, request);\n  this.emit(NetworkManagerEmittedEvents.Request, request);\n  request.finalizeInterceptions();\n}, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  if (request) {\n    request._fromMemoryCache = true;\n  }\n  this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n}, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect(request, responsePayload, extraInfo) {\n  const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responsePayload, extraInfo);\n  request._response = response;\n  request._redirectChain.push(request);\n  response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, false);\n  this.emit(NetworkManagerEmittedEvents.Response, response);\n  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent(responseReceived, extraInfo) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(responseReceived.requestId);\n  // FileUpload sends a response without a matching request.\n  if (!request) {\n    return;\n  }\n  const extraInfos = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(responseReceived.requestId);\n  if (extraInfos.length) {\n    debugError(new Error('Unexpected extraInfo events for request ' + responseReceived.requestId));\n  }\n  const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responseReceived.response, extraInfo);\n  request._response = response;\n  this.emit(NetworkManagerEmittedEvents.Response, response);\n}, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  let extraInfo = null;\n  if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n    extraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).shift();\n    if (!extraInfo) {\n      // Wait until we get the corresponding ExtraInfo event.\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueEventGroup(event.requestId, {\n        responseReceivedEvent: event\n      });\n      return;\n    }\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);\n}, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo(event) {\n  // We may have skipped a redirect response/request pair due to waiting for\n  // this ExtraInfo event. If so, continue that work now that we have the\n  // request.\n  const redirectInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").takeQueuedRedirectInfo(event.requestId);\n  if (redirectInfo) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);\n    return;\n  }\n  // We may have skipped response and loading events because we didn't have\n  // this ExtraInfo event yet. If so, emit those events now.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetQueuedEventGroup(event.requestId);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);\n    if (queuedEvents.loadingFinishedEvent) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);\n    }\n    if (queuedEvents.loadingFailedEvent) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);\n    }\n    return;\n  }\n  // Wait until we get another event that can use this ExtraInfo event.\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n}, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest(request, events) {\n  const requestId = request._requestId;\n  const interceptionId = request._interceptionId;\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequest(requestId);\n  interceptionId !== undefined && __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").delete(interceptionId);\n  if (events) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forget(requestId);\n  }\n}, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished(event) {\n  // If the response event for this request is still waiting on a\n  // corresponding ExtraInfo event, then wait to emit this event too.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    queuedEvents.loadingFinishedEvent = event;\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, event);\n  }\n}, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished(event) {\n  var _a;\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  // For certain requestIds we never receive requestWillBeSent event.\n  // @see https://crbug.com/750469\n  if (!request) {\n    return;\n  }\n  // Under certain conditions we never get the Network.responseReceived\n  // event from protocol. @see https://crbug.com/883475\n  if (request.response()) {\n    (_a = request.response()) === null || _a === void 0 ? void 0 : _a._resolveBody(null);\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed(event) {\n  // If the response event for this request is still waiting on a\n  // corresponding ExtraInfo event, then wait to emit this event too.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    queuedEvents.loadingFailedEvent = event;\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, event);\n  }\n}, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  // For certain requestIds we never receive requestWillBeSent event.\n  // @see https://crbug.com/750469\n  if (!request) {\n    return;\n  }\n  request._failureText = event.errorText;\n  const response = request.response();\n  if (response) {\n    response._resolveBody(null);\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n  this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n};","map":{"version":3,"mappings":"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","names":["assert","EventEmitter","HTTPRequest","HTTPResponse","NetworkEventManager","debugError","isString","createDebuggableDeferredPromise","NetworkManagerEmittedEvents","Request","Symbol","RequestServedFromCache","Response","RequestFailed","RequestFinished","NetworkManager","constructor","client","ignoreHTTPSErrors","frameManager","_NetworkManager_client","_NetworkManager_ignoreHTTPSErrors","_NetworkManager_frameManager","_NetworkManager_networkEventManager","_NetworkManager_extraHTTPHeaders","_NetworkManager_credentials","_NetworkManager_attemptedAuthentications","Set","_NetworkManager_userRequestInterceptionEnabled","_NetworkManager_protocolRequestInterceptionEnabled","_NetworkManager_userCacheDisabled","_NetworkManager_emulatedNetworkConditions","offline","upload","download","latency","_NetworkManager_deferredInitPromise","__classPrivateFieldSet","__classPrivateFieldGet","on","bind","initialize","init","Promise","all","send","ignore","deferredInitPromise","then","resolve","catch","err","reject","authenticate","credentials","setExtraHTTPHeaders","extraHTTPHeaders","key","Object","keys","value","toLowerCase","headers","assign","numRequestsInProgress","setOfflineMode","emulateNetworkConditions","networkConditions","setUserAgent","userAgent","userAgentMetadata","setCacheEnabled","enabled","setRequestInterception","_NetworkManager_updateNetworkConditions","uploadThroughput","downloadThroughput","_NetworkManager_updateProtocolRequestInterception","handleAuthRequests","patterns","urlPattern","_NetworkManager_updateProtocolCacheDisabled","cacheDisabled","event","request","url","startsWith","requestId","networkRequestId","storeRequestWillBeSent","requestPausedEvent","getRequestPaused","fetchRequestId","forgetRequestPaused","undefined","response","has","add","username","password","authChallengeResponse","networkId","requestWillBeSentEvent","getRequestWillBeSent","method","forgetRequestWillBeSent","storeRequestPaused","redirectChain","redirectResponse","redirectResponseExtraInfo","redirectHasExtraInfo","responseExtraInfo","shift","queueRedirectInfo","getRequest","_redirectChain","frame","frameId","storeRequest","emit","finalizeInterceptions","_fromMemoryCache","responsePayload","extraInfo","_response","push","_resolveBody","Error","responseReceived","extraInfos","length","hasExtraInfo","queueEventGroup","responseReceivedEvent","redirectInfo","takeQueuedRedirectInfo","queuedEvents","getQueuedEventGroup","forgetQueuedEventGroup","loadingFinishedEvent","loadingFailedEvent","events","_requestId","interceptionId","_interceptionId","forgetRequest","delete","forget","_failureText","errorText"],"sources":["../../../../src/common/NetworkManager.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}