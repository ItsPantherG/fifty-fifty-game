{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _NetworkEventManager_requestWillBeSentMap, _NetworkEventManager_requestPausedMap, _NetworkEventManager_httpRequestsMap, _NetworkEventManager_responseReceivedExtraInfoMap, _NetworkEventManager_queuedRedirectInfoMap, _NetworkEventManager_queuedEventGroupMap;\n/**\n * Helper class to track network events by request ID\n *\n * @internal\n */\nexport class NetworkEventManager {\n  constructor() {\n    /**\n     * There are four possible orders of events:\n     * A. `_onRequestWillBeSent`\n     * B. `_onRequestWillBeSent`, `_onRequestPaused`\n     * C. `_onRequestPaused`, `_onRequestWillBeSent`\n     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n     * (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     * A. `_onRequestWillBeSent`,\n     * `_onRequestWillBeSent`, ...\n     * B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     * `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     * C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     * `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     * D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n     * (see crbug.com/1196004)\n     */\n    _NetworkEventManager_requestWillBeSentMap.set(this, new Map());\n    _NetworkEventManager_requestPausedMap.set(this, new Map());\n    _NetworkEventManager_httpRequestsMap.set(this, new Map());\n    /*\n     * The below maps are used to reconcile Network.responseReceivedExtraInfo\n     * events with their corresponding request. Each response and redirect\n     * response gets an ExtraInfo event, and we don't know which will come first.\n     * This means that we have to store a Response or an ExtraInfo for each\n     * response, and emit the event when we get both of them. In addition, to\n     * handle redirects, we have to make them Arrays to represent the chain of\n     * events.\n     */\n    _NetworkEventManager_responseReceivedExtraInfoMap.set(this, new Map());\n    _NetworkEventManager_queuedRedirectInfoMap.set(this, new Map());\n    _NetworkEventManager_queuedEventGroupMap.set(this, new Map());\n  }\n  forget(networkRequestId) {\n    __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, \"f\").delete(networkRequestId);\n    __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, \"f\").delete(networkRequestId);\n    __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, \"f\").delete(networkRequestId);\n    __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, \"f\").delete(networkRequestId);\n    __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, \"f\").delete(networkRequestId);\n  }\n  responseExtraInfo(networkRequestId) {\n    if (!__classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, \"f\").has(networkRequestId)) {\n      __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, \"f\").set(networkRequestId, []);\n    }\n    return __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, \"f\").get(networkRequestId);\n  }\n  queuedRedirectInfo(fetchRequestId) {\n    if (!__classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, \"f\").has(fetchRequestId)) {\n      __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, \"f\").set(fetchRequestId, []);\n    }\n    return __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, \"f\").get(fetchRequestId);\n  }\n  queueRedirectInfo(fetchRequestId, redirectInfo) {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n  takeQueuedRedirectInfo(fetchRequestId) {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n  numRequestsInProgress() {\n    return [...__classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, \"f\")].filter(_ref => {\n      let [, request] = _ref;\n      return !request.response();\n    }).length;\n  }\n  storeRequestWillBeSent(networkRequestId, event) {\n    __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, \"f\").set(networkRequestId, event);\n  }\n  getRequestWillBeSent(networkRequestId) {\n    return __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, \"f\").get(networkRequestId);\n  }\n  forgetRequestWillBeSent(networkRequestId) {\n    __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, \"f\").delete(networkRequestId);\n  }\n  getRequestPaused(networkRequestId) {\n    return __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, \"f\").get(networkRequestId);\n  }\n  forgetRequestPaused(networkRequestId) {\n    __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, \"f\").delete(networkRequestId);\n  }\n  storeRequestPaused(networkRequestId, event) {\n    __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, \"f\").set(networkRequestId, event);\n  }\n  getRequest(networkRequestId) {\n    return __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, \"f\").get(networkRequestId);\n  }\n  storeRequest(networkRequestId, request) {\n    __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, \"f\").set(networkRequestId, request);\n  }\n  forgetRequest(networkRequestId) {\n    __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, \"f\").delete(networkRequestId);\n  }\n  getQueuedEventGroup(networkRequestId) {\n    return __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, \"f\").get(networkRequestId);\n  }\n  queueEventGroup(networkRequestId, event) {\n    __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, \"f\").set(networkRequestId, event);\n  }\n  forgetQueuedEventGroup(networkRequestId) {\n    __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, \"f\").delete(networkRequestId);\n  }\n}\n_NetworkEventManager_requestWillBeSentMap = new WeakMap(), _NetworkEventManager_requestPausedMap = new WeakMap(), _NetworkEventManager_httpRequestsMap = new WeakMap(), _NetworkEventManager_responseReceivedExtraInfoMap = new WeakMap(), _NetworkEventManager_queuedRedirectInfoMap = new WeakMap(), _NetworkEventManager_queuedEventGroupMap = new WeakMap();","map":{"version":3,"mappings":"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","names":["NetworkEventManager","constructor","_NetworkEventManager_requestWillBeSentMap","Map","_NetworkEventManager_requestPausedMap","_NetworkEventManager_httpRequestsMap","_NetworkEventManager_responseReceivedExtraInfoMap","_NetworkEventManager_queuedRedirectInfoMap","_NetworkEventManager_queuedEventGroupMap","forget","networkRequestId","__classPrivateFieldGet","delete","responseExtraInfo","has","set","get","queuedRedirectInfo","fetchRequestId","queueRedirectInfo","redirectInfo","push","takeQueuedRedirectInfo","shift","numRequestsInProgress","filter","request","response","length","storeRequestWillBeSent","event","getRequestWillBeSent","forgetRequestWillBeSent","getRequestPaused","forgetRequestPaused","storeRequestPaused","getRequest","storeRequest","forgetRequest","getQueuedEventGroup","queueEventGroup","forgetQueuedEventGroup"],"sources":["../../../../src/common/NetworkEventManager.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}