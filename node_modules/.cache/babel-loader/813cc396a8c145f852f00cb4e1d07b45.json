{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Connection_instances, _Connection_url, _Connection_transport, _Connection_delay, _Connection_lastId, _Connection_sessions, _Connection_closed, _Connection_callbacks, _Connection_manuallyAttached, _Connection_onClose, _CDPSessionImpl_sessionId, _CDPSessionImpl_targetType, _CDPSessionImpl_callbacks, _CDPSessionImpl_connection;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTargetClosedError = exports.CDPSessionImpl = exports.CDPSession = exports.CDPSessionEmittedEvents = exports.Connection = exports.ConnectionEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst assert_js_1 = require(\"../util/assert.js\");\nconst Debug_js_1 = require(\"./Debug.js\");\nconst debugProtocolSend = (0, Debug_js_1.debug)('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = (0, Debug_js_1.debug)('puppeteer:protocol:RECV ◀');\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst Errors_js_1 = require(\"./Errors.js\");\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexports.ConnectionEmittedEvents = {\n  Disconnected: Symbol('Connection.Disconnected')\n};\n/**\n * @public\n */\nclass Connection extends EventEmitter_js_1.EventEmitter {\n  constructor(url, transport) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    super();\n    _Connection_instances.add(this);\n    _Connection_url.set(this, void 0);\n    _Connection_transport.set(this, void 0);\n    _Connection_delay.set(this, void 0);\n    _Connection_lastId.set(this, 0);\n    _Connection_sessions.set(this, new Map());\n    _Connection_closed.set(this, false);\n    _Connection_callbacks.set(this, new Map());\n    _Connection_manuallyAttached.set(this, new Set());\n    __classPrivateFieldSet(this, _Connection_url, url, \"f\");\n    __classPrivateFieldSet(this, _Connection_delay, delay, \"f\");\n    __classPrivateFieldSet(this, _Connection_transport, transport, \"f\");\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = this.onMessage.bind(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).bind(this);\n  }\n  static fromSession(session) {\n    return session.connection();\n  }\n  /**\n   * @internal\n   */\n  get _closed() {\n    return __classPrivateFieldGet(this, _Connection_closed, \"f\");\n  }\n  /**\n   * @internal\n   */\n  get _sessions() {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\");\n  }\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId) {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId) || null;\n  }\n  url() {\n    return __classPrivateFieldGet(this, _Connection_url, \"f\");\n  }\n  send(method) {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    const params = (arguments.length <= 1 ? 0 : arguments.length - 1) ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n    const id = this._rawSend({\n      method,\n      params\n    });\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _Connection_callbacks, \"f\").set(id, {\n        resolve,\n        reject,\n        error: new Errors_js_1.ProtocolError(),\n        method\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  _rawSend(message) {\n    var _a;\n    const id = __classPrivateFieldSet(this, _Connection_lastId, (_a = __classPrivateFieldGet(this, _Connection_lastId, \"f\"), ++_a), \"f\");\n    const stringifiedMessage = JSON.stringify(Object.assign({}, message, {\n      id\n    }));\n    debugProtocolSend(stringifiedMessage);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").send(stringifiedMessage);\n    return id;\n  }\n  /**\n   * @internal\n   */\n  async onMessage(message) {\n    if (__classPrivateFieldGet(this, _Connection_delay, \"f\")) {\n      await new Promise(f => {\n        return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, \"f\"));\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);\n      __classPrivateFieldGet(this, _Connection_sessions, \"f\").set(sessionId, session);\n      this.emit('sessionattached', session);\n      const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit('sessionattached', session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.params.sessionId);\n      if (session) {\n        session._onClosed();\n        __classPrivateFieldGet(this, _Connection_sessions, \"f\").delete(object.params.sessionId);\n        this.emit('sessiondetached', session);\n        const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit('sessiondetached', session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n      if (session) {\n        session._onMessage(object);\n      }\n    } else if (object.id) {\n      const callback = __classPrivateFieldGet(this, _Connection_callbacks, \"f\").get(object.id);\n      // Callbacks could be all rejected if someone has called `.dispose()`.\n      if (callback) {\n        __classPrivateFieldGet(this, _Connection_callbacks, \"f\").delete(object.id);\n        if (object.error) {\n          callback.reject(createProtocolError(callback.error, callback.method, object));\n        } else {\n          callback.resolve(object.result);\n        }\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n  dispose() {\n    __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).call(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").close();\n  }\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId) {\n    return !__classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").has(targetId);\n  }\n  /**\n   * @internal\n   */\n  async _createSession(targetInfo) {\n    let isAutoAttachEmulated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!isAutoAttachEmulated) {\n      __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").add(targetInfo.targetId);\n    }\n    const {\n      sessionId\n    } = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").delete(targetInfo.targetId);\n    const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(targetInfo) {\n    return await this._createSession(targetInfo, false);\n  }\n}\nexports.Connection = Connection;\n_Connection_url = new WeakMap(), _Connection_transport = new WeakMap(), _Connection_delay = new WeakMap(), _Connection_lastId = new WeakMap(), _Connection_sessions = new WeakMap(), _Connection_closed = new WeakMap(), _Connection_callbacks = new WeakMap(), _Connection_manuallyAttached = new WeakMap(), _Connection_instances = new WeakSet(), _Connection_onClose = function _Connection_onClose() {\n  if (__classPrivateFieldGet(this, _Connection_closed, \"f\")) {\n    return;\n  }\n  __classPrivateFieldSet(this, _Connection_closed, true, \"f\");\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = undefined;\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = undefined;\n  for (const callback of __classPrivateFieldGet(this, _Connection_callbacks, \"f\").values()) {\n    callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n  }\n  __classPrivateFieldGet(this, _Connection_callbacks, \"f\").clear();\n  for (const session of __classPrivateFieldGet(this, _Connection_sessions, \"f\").values()) {\n    session._onClosed();\n  }\n  __classPrivateFieldGet(this, _Connection_sessions, \"f\").clear();\n  this.emit(exports.ConnectionEmittedEvents.Disconnected);\n};\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexports.CDPSessionEmittedEvents = {\n  Disconnected: Symbol('CDPSession.Disconnected')\n};\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nclass CDPSession extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  connection() {\n    throw new Error('Not implemented');\n  }\n  send() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    throw new Error('Not implemented');\n  }\n}\nexports.CDPSession = CDPSession;\n/**\n * @internal\n */\nclass CDPSessionImpl extends CDPSession {\n  /**\n   * @internal\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    _CDPSessionImpl_sessionId.set(this, void 0);\n    _CDPSessionImpl_targetType.set(this, void 0);\n    _CDPSessionImpl_callbacks.set(this, new Map());\n    _CDPSessionImpl_connection.set(this, void 0);\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, \"f\");\n  }\n  connection() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\");\n  }\n  send(method) {\n    if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`));\n    }\n    // See the comment in Connection#send explaining why we do this.\n    const params = (arguments.length <= 1 ? 0 : arguments.length - 1) ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n    const id = __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")._rawSend({\n      sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\"),\n      method,\n      params\n    });\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").set(id, {\n        resolve,\n        reject,\n        error: new Errors_js_1.ProtocolError(),\n        method\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  _onMessage(object) {\n    const callback = object.id ? __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").get(object.id) : undefined;\n    if (object.id && callback) {\n      __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").delete(object.id);\n      if (object.error) {\n        callback.reject(createProtocolError(callback.error, callback.method, object));\n      } else {\n        callback.resolve(object.result);\n      }\n    } else {\n      (0, assert_js_1.assert)(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n      throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`);\n    }\n    await __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\").send('Target.detachFromTarget', {\n      sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\")\n    });\n  }\n  /**\n   * @internal\n   */\n  _onClosed() {\n    for (const callback of __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").values()) {\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    }\n    __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").clear();\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, undefined, \"f\");\n    this.emit(exports.CDPSessionEmittedEvents.Disconnected);\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\");\n  }\n}\nexports.CDPSessionImpl = CDPSessionImpl;\n_CDPSessionImpl_sessionId = new WeakMap(), _CDPSessionImpl_targetType = new WeakMap(), _CDPSessionImpl_callbacks = new WeakMap(), _CDPSessionImpl_connection = new WeakMap();\nfunction createProtocolError(error, method, object) {\n  let message = `Protocol error (${method}): ${object.error.message}`;\n  if ('data' in object.error) {\n    message += ` ${object.error.data}`;\n  }\n  return rewriteError(error, message, object.error.message);\n}\nfunction rewriteError(error, message, originalMessage) {\n  error.message = message;\n  error.originalMessage = originalMessage !== null && originalMessage !== void 0 ? originalMessage : error.originalMessage;\n  return error;\n}\n/**\n * @internal\n */\nfunction isTargetClosedError(err) {\n  return err.message.includes('Target closed') || err.message.includes('Session closed');\n}\nexports.isTargetClosedError = isTargetClosedError;","map":{"version":3,"mappings":"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","names":["debugProtocolSend","debugProtocolReceive","exports","Disconnected","Symbol","Connection","EventEmitter_js_1","constructor","url","transport","delay","_Connection_url","_Connection_transport","_Connection_delay","_Connection_lastId","_Connection_sessions","Map","_Connection_closed","_Connection_callbacks","_Connection_manuallyAttached","Set","__classPrivateFieldSet","__classPrivateFieldGet","onmessage","onMessage","bind","onclose","fromSession","session","connection","_closed","_sessions","sessionId","get","send","method","params","undefined","id","_rawSend","Promise","resolve","reject","set","error","Errors_js_1","message","_a","stringifiedMessage","JSON","stringify","Object","assign","f","setTimeout","object","parse","CDPSessionImpl","targetInfo","type","emit","parentSession","_onClosed","delete","_onMessage","callback","createProtocolError","result","dispose","close","isAutoAttached","targetId","has","_createSession","isAutoAttachEmulated","add","flatten","Error","createSession","values","rewriteError","clear","CDPSession","detach","targetType","_CDPSessionImpl_sessionId","_CDPSessionImpl_targetType","_CDPSessionImpl_callbacks","_CDPSessionImpl_connection","data","originalMessage","isTargetClosedError","err","includes"],"sources":["../../../../src/common/Connection.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}